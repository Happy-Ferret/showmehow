[
    {
        "name": "showmehow",
        "desc": "Show me how to do things in this mysterious environment...",
        "entry": "showmehow",
        "practice": {
            "showmehow": {
                "task": "'showmehow' is a command that you can type, just like any other command. Try typing it and see what happens.",
                "effects": {
                    "success": {
                        "reply": "That's right! Though now you need to tell showmehow what task you want to try. This is called an 'argument'. Try giving showmehow an argument so that it knows what to do. Want to know what argument to give it? There's only one, and it just told you what it was.",
                        "move_to": "showmehow_argument"
                    },
                    "failure": {
                        "reply": "Nope, that wasn't what I thought would happen! Try typing just 'showmehow' and hit 'enter'. No more, no less (though surrounding spaces are okay)."
                    }
                }
            },
            "showmehow_argument": {
                "task": "Lets try giving an argument to 'showmehow'. Arguments are words that come after the main command",
                "input": "console",
                "effects": {
                    "success": {
                        "reply": "Great! Now that we're done with that, maybe you can run 'showmehow' again to find out what other things you can do in this mysterious place....",
                        "completes_lesson": true

                    },
                    "failure": {
                        "reply": "Hmmm. I want to know what happens when you ask how to use 'showmehow'"
                    }
                }
            }
        }
    },
    {
        "name": "joke",
        "available_to": ["console"],
        "desc": "Tell me a joke",
        "entry": "fortune",
        "practice": {
            "fortune": {
                "task": "'fortune' is a command that can tell you a joke",
                "effects": {
                    "success": {
                        "reply": "Ha-ha. Okay, lets try something even funnier.",
                        "move_to": "fortune_cowsay"
                    },
                    "failure": {
                        "reply": "No?"
                    }
                }
            },
            "fortune_cowsay": {
                "task": "In the shell, you can pipe (|) the output of commands around into other processes. One of these processes is 'cowsay'. See what happens when you try:\n    $ fortune | cowsay",
                "effects": {
                    "success": {
                        "reply": "Moo! Try some more jokes in the shell!",
                        "completes_lesson": true
                    },
                    "failure": {
                        "reply": "Hmm, I thought a cow was going to say that"
                    }
                }
            }
        }
    },
    {
        "name": "readfile",
        "available_to": ["console"],
        "desc": "Read a file",
        "entry": "cat",
        "practice": {
            "cat": {
                "task": "'cat' can be used to read files on your computer. Meow! Lets read the file on your computer which says what operating system we're running. That file is found at /etc/os-release",
                "input": "console",
                "effects": {
                    "success":{
                        "reply": "Endless OS, as expected. Meow!",
                        "move_to": "cat_cowsay"
                    },
                    "failure": {
                        "reply": "Hmm, are you sure you're reading /etc/os-release?"
                    }
                }
            },
            "cat_cowsay": {
                "task": "And for good measure, lets get a cow to say it too.",
                "input": "console",
                "effects": {
                    "success": {
                        "reply": "Moo! You can read any file that is plain text using `cat`. Try it with files like /etc/resolv.conf",
                        "completes_lesson": true
                    },
                    "failure": {
                        "reply": "Did you get a cow to say what's in /etc/os-release? Try again"
                    }
                }
            }
        }
    },
    {
        "name": "breakit",
        "available_to": ["console"],
        "desc": "See how it is almost impossible to break anything",
        "entry": "breakit",
        "practice": {
            "breakit": {
                "task": "Its pretty difficult to break things on the command line. Try typing gibberish.",
                "effects": {
                    "success": {
                        "reply": "See? Harmless. Don't be afraid to try new things!",
                        "completes_lesson": true,
                        "side_effects": [
                            {
                                "type": "unlock",
                                "value": ["changesetting", "playsong"]
                            }
                        ]
                    },
                    "failure": {
                        "reply": "Oops, you actually ended up running something!"
                    }
                }
            }
        }
    },
    {
        "name": "changesetting",
        "available_to": ["console"],
        "desc": "Escape the terminal and tweak the OS",
        "entry": "gsettings",
        "practice": {
            "gsettings": {
                "task": "Settings for your computer can be controlled with the `gsettings` tool. Lets find out what you can do with `gsettings`.",
                "effects": {
                    "success": {
                        "reply": "The `gsettings` tool just told you about a bunch of `commands`. You can access these commands by providing the command name as an argument to `gsettings`.",
                        "move_to": "list_schemas"
                    },
                    "failure": {
                        "reply": "I thought that you were going to run `gsettings`?"
                    }
                }
            },
            "list_schemas": {
                "task": "Lets try listing all the categories, called `schemas` on your system.",
                "effects": {
                    "success": {
                        "reply": "Those are all the categories. Now lets look at settings you can tweak in your shell.",
                        "move_to": "list_keys_help"
                    },
                    "failure": {
                        "reply": "Where are my settings categories? Try running the list-schemas subcommand for gsettings"
                    }
                }
            },
            "list_keys_help": {
                "task": "Lets see how to use the `list-keys` subcommand. You can use the `help` command followed by a sub-command you want help for to see how to use it",
                "effects": {
                    "success": {
                        "reply": "Okay, so gsettings [--schemadir SCHEMADIR] list-keys SCHEMA[:PATH] is how you do it",
                        "move_to": "list_settings"
                    },
                    "failure": {
                        "reply": "I don't know how to use this list-keys option! Get me some help for it!"
                    }
                }
            },
            "list_settings": {
                "task": "Now that we know how to use list-keys, lets list all the settings available on the org.gnome.shell category, or 'schema', as it is called. Pipe it to `sort` to get them in alphabetical order",
                "effects": {
                    "success": {
                        "reply": "Interesting.... I wonder what we can play around with here...",
                        "move_to": "disable_social_bar"
                    },
                    "failure": {
                        "reply": "I want to know about the settings available for org.gnome.shell in sorted order? Can you list-schemas on org.gnome.shell using gsettings and then pipe (|) the output to `sort`?"
                    }
                }
            },
            "disable_social_bar": {
                "task": "Lets disable the social bar! The social bar's setting is enable-social-bar and it is a `boolean` setting, meaning it is either 'true' or 'false'. I checked `gsettings help set` for you and it said you can use the `set` command to change a setting with gsettings [--schemadir SCHEMADIR] set SCHEMA[:PATH] KEY VALUE",
                "effects": {
                    "success": {
                        "reply": "There we go! No facebook icon!",
                        "move_to": "enable_social_bar"
                    },
                    "failure": {
                        "reply": "Hmm, I thought you'd change the value of org.gnome.shell enable-social-bar to false, but it is still true"
                    }
                }
            },
            "enable_social_bar": {
                "task": "Now lets change it back to true",
                "effects": {
                    "success": {
                        "reply": "Okay, phew, facebook is back",
                        "move_to": "add_terminal_pinned_help"
                    },
                    "failure": {
                        "reply": "Quick! I need facebook to come back! Change enable-social-bar on org.gnome.shell back to 'true'!"
                    }
                }
            },
            "add_terminal_pinned_help": {
                "task": "Oh I know, we should add the Terminal to your pinned apps! To do that, we can add it to the list inside of the taskbar-pins setting. But first lets see what the taskbar-pins setting looks like.",
                "effects": {
                    "success": {
                        "reply": "Okay, so it is a list in square brackets, where every element is surrounded by quotation marks and separated by a comma. Just like this: ['chromium-browser.desktop', 'my-other-app.desktop']",
                        "move_to": "add_terminal_pinned"
                    },
                    "failure": {
                        "reply": "You didn't show me your pinned apps!"
                    }
                }
            },
            "add_terminal_pinned": {
                "task": "Okay, lets pin the Terminal. The Terminal's App ID is 'org.gnome.Terminal', so we should add the 'org.gnome.Terminal.desktop' entry to that list in taskbar-pins",
                "effects": {
                    "success": {
                        "reply": "Sweet, looks like I'll be sticking around!",
                        "completes_lesson": true
                    },
                    "failure": {
                        "reply": "I'm not there :( The Terminal's App ID is 'org.gnome.Terminal', so we should add the 'org.gnome.Terminal.desktop' entry to that list in taskbar-pins"
                    }
                }
            }
        }
    },
    {
        "name": "playsong",
        "available_to": ["console"],
        "desc": "Play some music",
        "entry": "playsong",
        "practice": {
            "playsong": {
                "task": "Lets play some music. GStreamer is a framework that can be used to play all sorts of media files on your computer. Rythmbox and VideoNet both use it. To play a music file, just use `gst-launch-1.0`",
                "effects": {
                    "success": {
                        "reply": "I love this song! Now you'll probably notice that we're stuck here. To get out of any command line application, you can use Control-C",
                        "completes_lesson": true
                    },
                    "failure": {
                        "reply": "We need this song to get things into the right mood. Can you play it?"
                    }
                }
            }
        }
    },
    {
        "name": "navigation",
        "available_to": ["console"],
        "requires_session": true,
        "desc": "Navigate your file system",
        "entry": "change_to_root",
        "practice": {
            "change_to_root": {
                "task": "Lets start at the top and go to the top-down view of Endless. We'll change to the 'root directory', which is the very highest folder in your system. To do that, you just need to type $ cd /",
                "effects": {
                    "success": {
                        "reply": "Time to have a look around.",
                        "move_to": "list"
                    },
                    "failure": {
                        "reply": "Are you at the very very very top? Its just four characters! $ cd /"
                    }
                }
            },
            "list": {
                "task": "On the command line, you can show all the files and folders in the directory you're currently in, just like in the file manager. To do this, use the 'ls' command. Just type after the $ ls",
                "effects": {
                    "success": {
                        "reply": "I bet you've never seen some of these files before. Lets have a look at what they are...",
                        "move_to": "list_child"
                    },
                    "failure": {
                        "reply": "Hmmm, try listing the files again, I didn't see what I expected to see"
                    }
                }
            },
            "list_child": {
                "task": "You can also see what's inside any particular folder. Try listing the contents of /home",
                "effects": {
                    "success": {
                        "reply": "See anything familiar in there? Every user on the system has their own directory.",
                        "move_to": "pwd"
                    },
                    "failure": {
                        "reply": "Hmmm, are you sure that is /home?"
                    }
                }
            },
            "pwd": {
                "task": "You might wonder what folder you're in right now? You can find out with 'pwd'",
                "effects": {
                    "success": {
                        "reply": "Wow, that's a short folder name. In fact, you're in what's called the 'root' directory, which is where all the operating system files are stored",
                        "move_to": "cd"
                    },
                    "failure": {
                        "reply": "Hmmm, are you sure that is /home?"
                    }
                }
            },
            "cd": {
                "task": "You can change the 'working directory' with the 'cd' command. Lets try changing into the 'home' directory. Just like we did before, its 'cd' followed by the name of the directory.",
                "effects": {
                    "success": {
                        "reply": "Great! The context is now changed and you're in 'home'.",
                        "move_to": "cd_and_cmd"
                    },
                    "failure": {
                        "reply": "Hmmm, are you sure that is /home?"
                    }
                }
            },
            "cd_and_cmd": {
                "task": "You can change the working directory at any time with the 'cd' command, short for 'change directory'. You can also use '&&' to chain commands together. Try $ cd /home && ls",
                "effects": {
                    "success": {
                        "reply": "Just as expected! When you change the working directory with cd you are changing the context in which a command runs, so the 'ls' command listed what was in 'home' directory.",
                        "move_to": "cd_home_dir"
                    },
                    "failure": {
                        "reply": "Hmmm, are you sure that is /home you listed?"
                    }
                }
            },
            "cd_home_dir": {
                "task": "You're probably wondering if there's a quick way to get into your home directory, since that's where you usually start. Turns out there is - the tilde (~, just above the Tab key) is a shortcut that always expands to the path of your home directory. Why don't you try changing to your home directory?",
                "effects": {
                    "success": {
                        "reply": "I'm sure you'll see some familiar stuff in here!",
                        "move_to": "list_home_dir"
                    },
                    "failure": {
                        "reply": "Hmmm, are sure you changed into your home directory??"
                    }
                }
            },
            "list_home_dir": {
                "task": "Now that you're here, why not list the contents of it. Just like before.",
                "effects": {
                    "success": {
                        "reply": "Go check if that's what you expected in the file manager!",
                        "move_to": "mkdir"
                    },
                    "failure": {
                        "reply": "Hmmm, are sure you listed your home directory??"
                    }
                }
            },
            "mkdir": {
                "task": "Now that you're getting pretty good at navigating around, what about making some new files and directories? The 'mkdir' command can be used to make a new folder. Why don't you try making a folder called ~/code? Remember that the ~ will expand to your home directory! Oh - and also, you might want to provide the '-p' switch to 'mkdir' just in case that folder is already there! So $ mkdir -p (the directory you're going to create)",
                "effects": {
                    "success": {
                        "reply": "Perhaps it might be worth checking in the file mananger to see if this folder was there!",
                        "move_to": "touch"
                    },
                    "failure": {
                        "reply": "Hmmm, I didn't see the directory. Did you make a folder named 'code' in your home directory?"
                    }
                }
            },
            "touch": {
                "task": "Now that we can make a directory, how about we try making a file, in our ~/code directory? Try making a file called 'secret.txt' in ~/code by using the 'touch' command.",
                "effects": {
                    "success": {
                        "reply": "Lets check that the file was there!",
                        "move_to": "write_to_secret"
                    },
                    "failure": {
                        "reply": "Hmmm, I didn't see the file. Did you make a file named 'secret.txt' in ~/code?"
                    }
                }
            },
            "write_to_secret": {
                "task": "Hey! Why don't we do something exciting and write down the academy password in the file we just created? Remember, it was 'kittens'. A quick shortcut to write something to a file is to use the redirect operator '>' after the command, which redirects its output to a file. One common pattern is to use the 'echo' command along with the redirect operator to overwrite a file. For instance, $ echo 'dogs' > cats.txt . Try writing 'kittens' to ~/code/secret.txt",
                "effects": {
                    "success": {
                        "reply": "Sweet, easy to find now!",
                        "completes_lesson": true
                    },
                    "failure": {
                        "reply": "Did you write 'kittens' to that file?"
                    }
                }
            }
        }
     }
]
